---
title: 二、Vue2.x-全局API
tags: Vue2.x
categories: Vue2.x
cover: https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-db7221c0d7ca752b2f88d7ca94939976_1440w.jpg&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=jpeg?sec=1645531271&t=ee378fdaea2d7c5a65a295534e38d247
abbrlink: 4f5a6bdd
date: 2019-04-06 00:00:00
---

# 全局 API

- 什么是全局 api？全局 API 并不在构造器里，而是先声明全局变量或者直接在 Vue 上定义一些新功能，Vue 内置了一些全局 API，在构造器外部用 Vue 提供给我们的 API 函数来定义新的功能。

## Vue.directive 自定义指令

- 实现一个指令，作用就是让文字变成绿色

  ```html
  <div id="app">
    <div v-jspang="color">{{ count }}</div>
  </div>
  <script>
    // 自定义全局的指令，我们这里使用Vue.directive()
    /* 
      自定义指令中传递三个参数
        el:      指令所绑定的元素，可以用来直接操作DOM。
        binding: 一个对象，包含指令的很多信息。
        vnode:   Vue编译生成的虚拟节点。
    */
    Vue.directive("jspang", (el, binding, vnode) => {
      el.style = "color:" + binding.value;
    });
    new Vue({
      el: "#app",
      data: {
        color: "green",
      },
    });
  </script>
  ```

- 自定义指令的生命周期

  ```html
  bind //
  只调用一次，指令第一次绑定到元素时调用，用这个钩子函数可以定义一个绑定时执行一次的初始化动作。
  inserted // 被绑定元素插入父节点时调用（父节点存在即可调用，不必存在于
  document 中）。 update //
  被绑定于元素所在的模板更新时调用，而无论绑定值是否变化。通过比较更新前后的绑定值，可以忽略不必要的模板更新。
  componentUpdated // 被绑定元素所在模板完成一次更新周期时调用。 unbind //
  只调用一次，指令与元素解绑时调用。

  <div id="app">
    <button @click="add">Add</button>
    <div><button onclick="unbind()">解除指令绑定</button></div>
  </div>
  <script>
    // 自定义全局的指令，我们这里使用Vue.directive()
    /* 
      自定义指令中传递三个参数
        el:      指令所绑定的元素，可以用来直接操作DOM。
        binding: 一个对象，包含指令的很多信息。
        vnode:   Vue编译生成的虚拟节点。
    */
    // 1.自定义指令生命周期
    Vue.directive("jspang", {
      bind: function (el, binding, vnode) {
        // 被绑定
        el.style = "color:" + binding.value;
        console.log("1 - bind，被绑定的时候触发！");
      },
      inserted: function () {
        // 绑定到节点
        console.log("2 - inserted，绑定到dom节点上触发！");
      },
      update: function () {
        // 组件更新
        console.log("3 - update，组件更新触发！");
      },
      componentUpdated: function () {
        // 组件更新完成
        console.log("4 - componentUpdated，组件更新完成触发！");
      },
      unbind: function () {
        // 解绑
        console.log("5 - unbind，解绑触发！");
      },
    });
    // js原生解除绑定函数
    function unbind() {
      app.$destroy();
    }
    new Vue({
      el: "#app",
      data: {
        count: 10,
        color: "green",
      },
      methods: {
        add: function () {
          this.count++;
        },
      },
    });
  </script>
  ```

## Vue.extend 构造器的延申

- 什么是 Vue.extend 返回的是一个“扩展实例构造器”,也就是预设了部分选项的 Vue 实例构造器。经常服务于 Vue.component 用来生成组件，可以简单理解为当在模板中遇到该组件名称作为标签的自定义元素时，会自动调用“扩展实例构造器”来生产组件实例，并挂载到自定义元素上。

- **）我们想象一个需求，需求是这样的，要在博客页面多处显示作者的网名，并在网名上直接有链接地址。我们希望在 html 中只需要写`<author></author>`，这和自定义组件很像，但是他没有传递任何参数，只是个静态标签。**

  - 我们的 Vue.extend 该登场了，我们先用它来编写一个扩展实例构造器。代码如下：

    ```javascript
    var authorExtend = Vue.extend({
      template: "<p><a :href='authorUrl'>{{authorName}}</a></p>",
      data: function () {
        return {
          authorName: "JSPang",
          authorUrl: "http://www.jspang.com",
        };
      },
    });
    ```

  - 这时 html 中的标签还是不起作用的，因为扩展实例构造器是需要挂载的，我们再进行一次挂载。

    ```javascript
    new authorExtend().$mount("author");
    ```

  - 这时我们在 html 写`<author><author>`就是管用的。我们来看一下全部代码：

    ```html
    <div id="app">
      <h1>Vue.extend 扩展实例构造器</h1>
      <hr />
      <author id="author"></author>
    </div>
    <script>
      /* 
          1.创建构造器对象
          2.写入传入模板对象
         */
      var authorExtend = Vue.extend({
        template:
          "<p><a :href='authorUrl'>{{ ${authorName}--${authorUrl} }}</p>",
        data: function () {
          return {
            authorName: "个人博客",
            authorUrl: "http://louhaojie99.top",
          };
        },
      });
      // 绑定 , Vue的$mount()为手动挂载
      new authorExtend().$mount("#author");

      var app = new Vue({
        el: "#app",
        data: {},
      });
    </script>
    +'0'
    ```

- **）挂在普通标签上**

  - 还可以通过 HTML 标签上的 id 或者 class 来生成扩展实例构造器，Vue.extend 里的代码是一样的，只是在挂载的时候，我们用类似 jquery 的选择器的方法，来进行挂载就可以了。

    ```javascript
    new authorExtend().$mount("#author");
    ```

## Vue.set 全局操作

- Vue.set 的作用就是在构造器外部操作构造器内部的数据、属性或者方法。比如在 vue 构造器内部定义了一个 count 为 1 的数据，我们在构造器外部定义了一个方法，要每次点击按钮给值加 1.就需要用到 Vue.set。

- **）引用构造器外部数据：**

  - 什么是外部数据，就是不在 Vue 构造器里里的 data 处声明，而是在构造器外部声明，然后在 data 处引用就可以了。外部数据的加入让程序更加灵活，我们可以在外部获取任何想要的数据形式，然后让 data 引用。 看一个简单的代码：

  ```javascript
  //在构造器外部声明数据
  var outData = {
    count: 1,
    goodName: "car",
  };
  var app = new Vue({
    el: "#app",
    //引用外部数据
    data: outData,
  });
  ```

- **在外部改变数据的三种方法：**

  1. 用 Vue.set 改变

     ```javascript
     function add() {
       Vue.set(outData, "count", 4);
     }
     ```

  2. 用 Vue 对象的方法添加

     ```javascript
     app.count++;
     ```

  3. 直接操作外部数据

     ```javascript
     outData.count++;
     ```

     其实这三种方式都可以操作外部的数据，Vue 也给我们增加了一种操作外部数据的方法。

- **）为什么要有 Vue.set 的存在？**

  - 由于 JavaScript 的限制，Vue 不能检测数组下标赋值、长度变化、对象属性动态添加和删除
  - 当你利用索引直接设置一个项时，vue 不会为我们自动更新
  - 当你修改数组的长度时，vue 不会为我们自动更新

  ```html
  <!-- 
  实验目的：  
  Vue不能检测数组下标赋值、长度变化、对象属性动态添加和删除的原因和解决办法
  -->
  <div id="app">
    <ul>
      <li v-for="item in arr">{{ item }}</li>
    </ul>
    <button @click="changeFirstData">点击改变arr[0]项的值</button>
    <hr />
    <div>{{ obj }}</div>
    <button @click="changeObjAdd">对象属性动态添加</button>
    <button @click="changeObjDel">对象属性动态删除</button>
  </div>
  <script>
    new Vue({
      el: "#app",
      data: {
        arr: ["孙悟空", "贝吉塔", "特兰克斯"],
        obj: {
          name: "娄豪杰",
          age: 20,
        },
      },
      methods: {
        changeFirstData: function () {
          this.arr[0] = "娄豪杰"; // 改变不了
          // Vue.set(this.arr, 0 , '美猴王')   // 解决方案一
          this.$set(this.arr, 0, "美猴王"); // 解决方案二
        },
        changeObjAdd() {
          // this.obj.sex = "男"              // 无法改变
          this.$set(this.obj, "sex", "男");
        },
        changeObjDel() {
          this.$set(this.obj, "sex", undefined);
        },
      },
    });
  </script>
  ```

- **）如何监听数组某一项的变化？**

  - 答：首先改变数组某一项的值的话，我们会使用 this.$set()；监听变化我会使用到 computed 和 watch 同时使用，使用计算属性转为字符串再转换为对象返回是为了避免 watch 监听时返回的新旧数据是一样的，然后 watch 监听刚刚计算属性定义的那个方法即可.

  ```html
  <!-- 
  实验目的：  
  Vue不能检测数组下标赋值、长度变化、对象属性动态添加和删除的原因和解决办法
  -->
  <div id="app">
    <ul>
      <li v-for="item in arr">{{ item }}</li>
    </ul>
    <button @click="hanldChange">改变数组测试按钮</button>
  </div>
  <script>
    new Vue({
      el: "#app",
      data: {
        arr: ["111", "222", "333", "444"],
      },
      // 在computed监听新变量 , 一定要用JSON.parse 和 JSON.stringify 转化一下, 不然watch监听时返回的新旧值还是一样的 .
      computed: {
        computedArr: function () {
          return JSON.parse(JSON.stringify(this.arr));
        },
      },
      // watch监听 , handler函数的两种写法都是可以的, 但是不能使用箭头函数 .
      watch: {
        computedArr: {
          handler: function (newVal, oldVal) {
            console.log("新值-----", newVal);
            console.log("旧值-----", oldVal);
            if (newVal !== oldVal) {
              console.log("数组变化了!!!");
            }
          },
          // immediate : true //初始化页面后立即监听
        },
      },
      methods: {
        hanldChange: function () {
          this.$set(this.arr, 0, "美猴王");
        },
      },
    });
  </script>
  ```

## Vue 的生命周期

- Vue 一共有 10 个生命周期函数，我们可以利用这些函数在 vue 的每个阶段都进行操作数据或者改变内容。

```html
<div id="app">
  {{message}}
  <p><button @click="jia">加分</button></p>
</div>
<button onclick="app.$destroy()">销毁</button>
<script type="text/javascript">
  var app = new Vue({
    el: "#app",
    data: {
      message: 1,
    },
    methods: {
      jia: function () {
        this.message++;
      },
    },
    beforeCreate: function () {
      console.log("1-beforeCreate 初始化之后");
    },
    created: function () {
      console.log("2-created 创建完成");
    },
    beforeMount: function () {
      console.log("3-beforeMount 挂载之前");
    },
    mounted: function () {
      console.log("4-mounted 被创建");
    },
    beforeUpdate: function () {
      console.log("5-beforeUpdate 数据更新前");
    },
    updated: function () {
      console.log("6-updated 被更新后");
    },
    beforeDestroy: function () {
      console.log("7-beforeDestroy 销毁之前");
    },
    destroyed: function () {
      console.log("8-destroyed 销毁之后");
    },
    activated: function () {
      console.log("9-activated");
    },
    deactivated: function () {
      console.log("10-deactivated");
    },
  });
</script>

<!--
Vue的<keep-alive></keep-alive>的两个生命周期用法（activated、deactivated）
- <keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <transition> 
  相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。
  当组件在 <keep-alive> 内被切换，它的 activated 和 deactivated 
  这两个生命周期钩子函数将会被对应执行。

- 注意：只有当组件在 <keep-alive> 内被切换，才会有 activated 和 deactivated 这两个钩
  子函数通过描述我们知道，它会缓存不活动的组件，而不是销毁。这样组件之间的切换就能保存上个组件
  的状态，而不是切换之后又得重新操作。
-->
```

## Template 制作模板

- 写在 template 标签里的模板

  ```html
  <!-- 这里需要注意的是模板的标识不是单引号和双引号，而是，就是 Tab 上面的键。 -->
  <template id="demo2">
    <h2 style="color:red">我是template标签模板</h2>
  </template>

  <script type="text/javascript">
    var app = new Vue({
      el: "#app",
      data: { message: "hello Vue!" },
      template: "#demo2",
    });
  </script>
  ```

- 写在 script 标签里的模板

  ```html
  <!-- 这种写模板的方法，可以让模板文件从外部引入。 -->
  <script type="x-template" id="demo3">
    <h2 style="color:red">我是script标签模板</h2>
  </script>

  <script type="text/javascript">
    var app = new Vue({
      el: "#app",
      data: {
        message: "hello Vue!",
      },
      template: "#demo3",
    });
  </script>
  ```

## Component 初识组件

### ）全局化注册组件

```html
<!-- 全局化就是在构造器的外部用 Vue.component 来注册，我们注册现在就注册一个组件来体验一下 -->
<div id="main">
  <louhaojie></louhaojie>
</div>
<script>
  // 1.注册全局组件
  Vue.component("louhaojie", {
    template: `<div style="color: red;">全局化注册的louhaojie标签</div>`,
  });
  new Vue({
    el: "#main",
    data: {
      messgae: "123456",
    },
  });
</script>
```

### ）局部注册组件

```html
<!-- 局部注册组件局部注册和全局注册组件是相对应的，局部注册的组件只能在组件注册的作用域进行使用，其他作用域使用无效。 -->
<div id="main">
  <louhaojie></louhaojie>
</div>
<script>
  new Vue({
    el: "#main",
    data: {},
    components: {
      louhaojie: {
        template: `<div style='color: #ff0000;'>局部注册的louhaojie标签</div>`,
      },
    },
  });
</script>
```

## Component 组件 props 属性设置

- props 选项就是设置和获取标签上的属性值的，例如我们有一个自定义的组件,这时我们想给他加个标签属性写成 意思就是熊猫来自中国，当然这里的 China 可以换成任何值。定义属性的选项是 props。

### ）定义属性并获取值

- 定义属性我们需要用 props 选项，加上数组形式的属性名称，例如：props:[‘here’]。在组件的模板里读出属性值只需要用插值的形式，例如{{ here }}.

  ```html
  <div id="main">
    <louhaojie here="杭州"></louhaojie>
  </div>
  <script>
    /* 
        props选项就是设置和获取标签上的属性值的，例如我们有有一个自定义的组件，这时我们项给他加个标签
        属性写成意思就是熊猫来自中国，当然这里的China可以换成任何值。定义属性的选项是props。
      */
    // 一、定义属性并获取属性值
    new Vue({
      el: "#main",
      data: {},
      components: {
        louhaojie: {
          template: `
  <div style='color: #ff0000;'>欢迎来到{{ here }}！！！</div>
  `,
          props: ["here"],
        },
      },
    });
  </script>
  ```

### ）属性中待'-'的处理方式

- 我们在写属性时经常会加入’-‘来进行分词，比如：，那这时我们在 props 里如果写成 props:[‘form-here’]是错误的，我们必须用小驼峰式写法 props:[‘formHere’]。

  ```html
  <div id="app">
    <panda from-here="China"></panda>
  </div>
  <script>
    new Vue({
      el: "#app",
      components: {
        panda: {
          template: `<div style="color:red;">Panda from {{ here }}.</div>`,
          props: ["fromHere"],
        },
      },
    });
  </script>
  ```

### ）在构造器里向组件中传值

- 把构造器中 data 的值传递给组件，我们只要进行绑定就可以了。就是我们第一季学的 v-bind:xxx.我们直接看代码

  ```html
  <div id="app">
    <panda v-bind:here="message"></panda>
  </div>

  <script>
    new Vue({
      el: "#app",
      data: {
        message: "SiChuan",
      },
      components: {
        panda: {
          template: `<div style="color:red;">Panda from {{ here }}.</div>`,
          props: ["here"],
        },
      },
    });
  </script>
  ```

## Component 标签

- 标签是 Vue 框架自定义的标签，它的用途就是可以动态绑定我们的组件，根据数据的不同更换不同的组件。

1. 我们先在构造器外部定义三个不同的组件，分别是 componentA,componentB 和 componentC.

   ```javascript
   var componentA = {
     template: `<div>I'm componentA</div>`,
   };
   var componentB = {
     template: `<div>I'm componentB</div>`,
   };
   var componentC = {
     template: `<div>I'm componentC</div>`,
   };
   ```

2. 我们在构造器的 components 选项里加入这三个组件。

   ```javascript
   components:{
       "componentA":componentA,
       "componentB":componentB,
       "componentC":componentC,
   }
   ```

3. 我们在 html 里插入 component 标签，并绑定 who 数据，根据 who 的值不同，调用不同的组件。

   ```javascript
   <component v-bind:is="who"></component>
   ```

   这就是我们的组件标签的基本用法。我们提高以下，给页面加个按钮，每点以下更换一个组件。

   ```html
   <!DOCTYPE html>
   <html lang="en">
     <head>
       <meta charset="UTF-8" />
       <script type="text/javascript" src="../assets/js/vue.js"></script>
       <title>component-4</title>
     </head>
     <body>
       <h1>component-4</h1>
       <hr />
       <div id="app">
         <component v-bind:is="who"></component>
         <button @click="changeComponent">changeComponent</button>
       </div>

       <script type="text/javascript">
         var componentA = {
           template: `<div style="color:red;">I'm componentA</div>`,
         };
         var componentB = {
           template: `<div style="color:green;">I'm componentB</div>`,
         };
         var componentC = {
           template: `<div style="color:pink;">I'm componentC</div>`,
         };

         var app = new Vue({
           el: "#app",
           data: {
             who: "componentA",
           },
           components: {
             componentA: componentA,
             componentB: componentB,
             componentC: componentC,
           },
           methods: {
             changeComponent: function () {
               if (this.who == "componentA") {
                 this.who = "componentB";
               } else if (this.who == "componentB") {
                 this.who = "componentC";
               } else {
                 this.who = "componentA";
               }
             },
           },
         });
       </script>
     </body>
   </html>
   ```
